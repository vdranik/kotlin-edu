package kotl

fun main() {

    // использование функции высшего порядка
    val result = modifyString("Hello World") { it.toUpperCase() } // если лямбда выражение явл. последним параметром, то его можно выносить за круглые скобки
    println(result)



    val list = (0..100).toList()
    // Если функцию не объявить как inline, то будет создан объект анонимного класса, а только потом будет вызван метод, что избыточно
    listModify(list) {      // 1й аргумент, список чисел
        println(it.sum())   // 2й аргумент, функция выводит сумму чисел, и без inline это будет новый объект анонимного класса
    }

    // с inline компилятор отработает так:
    println(list.sum()) // этот код будет встроен вместо вызова функции

}

// функция высшего порядка, принимает строку и функцию которую ее изменяет
fun modifyString(string: String, modify: (String) -> String): String {
    return modify(string)
}

// Если создаем небольшой метод, который в качестве параметра принимает функцию, то ее следует объявить как inline (все стандартные функции в kotlin - inline)
// Не будет создаваться объект анонимного класса, просто код будет встроен вместо вызова функции (просто println(list.sum()))
inline fun listModify(list: List<Int>, operator: (List<Int>) -> Unit) {  // не возвращает результат
    operator(list)
}

// TODO Почему все функции высшего порядка не объявить inline?